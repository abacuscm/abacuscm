<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<chapter id="developer">
    <title>Developer manual</title>
    <section id="developer.build">
        <title>Build system</title>
        <para>TODO</para>
    </section>

    <section id="developer.standard">
        <title>Coding standard</title>
        <section id="developer.standard.files">
            <title>Files</title>
            <itemizedlist>
                <listitem>
                    <para>
                        C++ files have the extension <filename
                            class="extension">.C</filename>, and are placed in
                        the <filename class="directory">src</filename>
                        directory.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Header files have the extension <filename
                            class="extension">.h</filename>, and are placed in
                        the <filename class="directory">include</filename>
                        directory.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        UI descriptions for Qt Designer have the extension
                        <filename class="extension">.ui</filename> and are
                        placed in the <filename
                            class="directory">ui</filename> directory.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Filenames are lower-case (apart from the extension)
                        and generally only use underscores to with a prefix to
                        indicate a group of related files (files generated by
                        <command>uic</command> are called
                        <filename>ui_<replaceable>filename</replaceable>.C</filename>,
                        while action handlers are called
                        <filename>act_<replaceable>actions</replaceable>.C</filename>).
                        There are a few exceptions to this rule, but they are
                        historic aberrations and may eventually be fixed.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Where a header file and a C++ file correspond, they
                        should have the same name. There are a few headers
                        that have no corresponding C++ file, and there are
                        also a few historic aberrations.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The <filename class="directory">obj</filename>,
                        <filename class="directory">bin</filename>,
                        <filename class="directory">lib</filename>,
                        <filename class="directory">modules</filename>,
                        <filename class="directory">tex-tmp</filename> and
                        <filename class="directory">deps</filename>
                        directories should only contain generated files, not
                        sources.
                    </para>
                </listitem>
            </itemizedlist>
        </section>
        <section id="developer.standard.style">
            <title>Coding style</title>
            <itemizedlist>
                <listitem>
                    <para>
                        Indentation uses tab characters, not spaces. Where
                        tabs are used to create alignment, the tab size should
                        be set to 4 spaces.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Opening braces are placed at the end of a line of
                        code, not on their own line.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Class names use
                        <classname><replaceable>InterCaps</replaceable></classname>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Private data members of classes are lower-case with
                        underscore separation and leading underscores e.g.,
                        <varname><replaceable>_private_member</replaceable></varname>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Methods use
                        <methodname><replaceable>camelCase</replaceable></methodname>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Non-method functions and variables use
                        lower-case and underscores e.g.,
                        <function><replaceable>my_function</replaceable></function>.
                    </para>
                </listitem>
            </itemizedlist>
        </section>
        <section id="developer.standard.singleton">
            <title>Singleton pattern</title>
            <para>TODO</para>
        </section>
    </section>

    <section id="developer.common">
        <title>Common infrastructure</title>
        <section id="developer.common.logging">
            <title>Logging</title>
            <para>
                General logging is done by calling
            </para>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>void <function>log</function></funcdef>
                    <paramdef>int <parameter>priority</parameter></paramdef>
                    <paramdef>const char *<parameter>format</parameter></paramdef>
                    <paramdef>...</paramdef>
                </funcprototype>
            </funcsynopsis>
            <para>
                The level and destination of logging is controlled by the
                configuration file. The <parameter>priority</parameter> values
                are taken from <function>syslog</function>. The
                <parameter>format</parameter> and variadic arguments are as
                used by <function>printf</function>.
            </para>
            <para>
                There is also an <function>lerror</function> macro which
                can be called when a system call fails unexpectedly. It logs
                the location of the error and the error message. Finally,
                there are some special-purpose functions for logging
                <systemitem class="library">OpenSSL</systemitem>
                errors (refer to <filename
                    class="headerfile">include/logger.h</filename>).
            </para>
        </section>
        <section id="developer.common.config">
            <title>Configuration files</title>
            <para>TODO</para>
        </section>
        <section id="developer.common.score">
            <title>Score comparison</title>
            <para>TODO</para>
        </section>
    </section>

    <section id="developer.csprotocol">
        <title>Client-server protocol</title>
        <section id="developer.csprotocol.intro">
            <title>Introduction</title>
            <para>
                The client-server protocol is encrypted with SSL over a TCP/IP
                connection. The transport is standard and so only the payload
                is discussed here.
            </para>
            <para>
                The protocol is semi-synchronous: the client makes requests
                and then blocks waiting for a synchronous reply from the
                server. However, the server may also sent asynchronous
                notifications to the client at any time.
            </para>
            <para>
                The protocol is text-based rather than binary. Lines are
                terminated by UNIX newline characters (<code>\n</code>), and
                the character encoding is UTF-8. Invalid UTF-8 encodings are
                not permitted, although currently this is not enforced.
            </para>
        </section>
        <section id="developer.csprotocol.format">
            <title>Message format</title>
            <para>
                A message consists of a type and a set of key/value pairs. The
                type appears first on a line of its own. After this, key/value
                pairs appear one per line, in the form
                <literal><replaceable>header</replaceable>:<replaceable>value</replaceable></literal>.
                At present, the parsing code has no restrictions on the type
                or the headers, but it is recommended that they be limited to
                ASCII alphanumerics and <literal>-</literal> (hyphen)
                characters. Headers may be sent in any order, but are
                case-sensitive.
            </para>
            <para>
                The message headers are terminated by a blank line. Usually
                this terminates the message, but a message may also have a
                binary content blob associated with it. The presence of this
                blob is indicated by a
                <parameter>content-length</parameter> header. The
                value of this header must be a non-negative decimal integer
                containing the number of bytes in the content blob. The content
                blob itself immediately follows the blank line that follows
                the headers.
            </para>
            <example>
                <title>A sample message</title>
                <synopsis>auth
user:<replaceable>username</replaceable>
pass:<replaceable>password</replaceable>

</synopsis>
            </example>
            <para>
                On top of this basic protocol, there are a few standard ways
                to encode more structured information. An ordered list of
                values is returned by using sequentially numbered headers,
                starting from 0 e.g., headers
                <parameter>header0</parameter>,
                <parameter>header1</parameter> and
                <parameter>header2</parameter>. Tables of values
                with fixed columns use the same approach for each column of
                the table.
            </para>
            <para id="developer.csprotocol.grid">
                For messages that return general two-dimensional tables,
                headers <parameter>nrows</parameter> and
                <parameter>ncols</parameter> contain the dimensions
                of the table, and the elements are stored in headers called
                <parameter>row_<replaceable>row</replaceable>_<replaceable>column</replaceable></parameter>,
                where <replaceable>row</replaceable> and
                <replaceable>column</replaceable> are indexed from zero. Row
                zero contains the column headers. Note
                that messages that use this scheme can only contain one table.
            </para>
        </section>
        <section id="developer.csprotocol.client">
            <title>Client commands</title>
            <para>
                These are commands that the client sends to the server. The
                server will always reply with either an <type>ok</type>
                message or an <type>err</type> message. Where the
                <type>ok</type> message contains information, it is shown
                in the synopses below; where it contains no information it
                is omitted.
            </para>
            <section id="developer.csprotocol.auth">
                <title>Authentication</title>
                <synopsis>auth
user:<replaceable>username</replaceable>
pass:<replaceable>password</replaceable>

ok
user:<replaceable>user</replaceable></synopsis>
                <para>
                    This is typically the first message, used to log in. The
                    username is repeated in a successful reply to simplify the
                    client logic.
                </para>
                <para>
                    The web interface uses a special form of this message
                    where the username and password fields are omitted
                    (entirely absent, rather than blank). This requests the
                    servlet to log in using credentials cached in the web
                    server, rather than provided by the client. These fields
                    are filled in before being passed to the abacus server.
                </para>
            </section>
            <section id="developer.csprotocol.whatami">
                <title>Query permissions</title>
                <synopsis>whatami
permission0:<replaceable>permission</replaceable>
permission1:<replaceable>permission</replaceable>
&hellip;</synopsis>
                <para>
                    The possible values for
                    <replaceable>permission</replaceable> can be found in
                    <filename>src/permissions.C</filename>.
                </para>
            </section>
            <section id="developer.csprotocol.adduser">
                <title>Create a user</title>
                <synopsis>adduser
username:<replaceable>username</replaceable>
friendlyname:<replaceable>team name</replaceable>
passwd:<replaceable>password</replaceable>
type:<replaceable>user type</replaceable> <co id="adduser.type.co"
    linkends="adduser.type"/></synopsis>
                <calloutlist>
                    <callout id="adduser.type" arearefs="adduser.type.co">
                        <para>
                            One of
                            <literal>contestant</literal>,
                            <literal>observer</literal>,
                            <literal>judge</literal>,
                            <literal>admin</literal> or
                            <literal>marker</literal>.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section id="developer.csprotocol.getusers">
                <title>Get list of users</title>
                <synopsis>getusers

ok
id0:<replaceable>id</replaceable>
username0:<replaceable>username</replaceable></synopsis>
            </section>
            <section id="developer.csprotocol.passwd">
                <title>Change own password</title>
                <synopsis>passwd
newpass:<replaceable>password</replaceable></synopsis>
            </section>
            <section id="developer.csprotocol.id_passwd">
                <title>Change another user's password</title>
                <screen>id_passwd
user_id:<replaceable>id</replaceable> <co id="id_passwd.user_id.co" linkends="id_passwd.user_id"/>
newpass:<replaceable>password</replaceable></screen>
                <calloutlist>
                    <callout id="id_passwd.user_id" arearefs="id_passwd.user_id.co">
                        <para>
                            The internal numeric ID, rather than a
                            username.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section id="developer.csprotocol.getlanguages">
                <title>Get list of permitted languages</title>
                <synopsis>getlanguages

ok
language0:<replaceable>language</replaceable>
language1:<replaceable>language</replaceable>
&hellip;</synopsis>
                <para>
                    The possible values of
                    <replaceable>language</replaceable> are
                    <literal>C</literal>,
                    <literal>C++</literal>,
                    <literal>Python</literal> and
                    <literal>Java</literal> (although more languages may be
                    available in future).
                </para>
            </section>
            <section id="developer.csprotocol.getprobtypes">
                <title>Get list of problem types</title>
                <synopsis>getprobtypes

ok
type0:<replaceable>type</replaceable>
type1:<replaceable>type</replaceable>
&hellip;</synopsis>
                <para>
                    The problem types are arbitrary strings that can be
                    passed back to the server with a
                    <type>getprobdescipt</type> or
                    <type>setprobattrs</type> message. They are suitable
                    for presentation to the user when creating a new
                    problem.
                </para>
            </section>
            <section id="developer.csprotocol.getprobdescript">
                <title>Get information about a problem type</title>
                <synopsis>getprobdescript
type:<replaceable>type</replaceable>

ok
descript:<replaceable>description</replaceable></synopsis>
                <para>
                    TODO: document the mini-language used for descriptions
                </para>
            </section>
            <section id="developer.csprotocol.setprobattrs">
                <title>Create or update problem</title>
                <synopsis>setprobattrs
prob_id:<replaceable>id</replaceable>                    <co id="setprobattrs.prob_id.co" linkends="setprobattrs.prob_id"/>
prob_type:<replaceable>type</replaceable>                <co id="setprobattrs.prob_type.co" linkends="setprobattrs.prob_type"/>
<optional>prob_dependencies:<replaceable>problem</replaceable>,&hellip;</optional> <co id="setprobattrs.prob_dependencies.co" linkends="setprobattrs.prob_dependencies"/>
<replaceable>key</replaceable>:<replaceable>value</replaceable>                     <co id="setprobattrs.key.co" linkends="setprobattrs.key"/>
<replaceable>key</replaceable>:<replaceable>value</replaceable>                     <coref linkend="setprobattrs.key.co"/>
&hellip;
<replaceable>key</replaceable>:<replaceable>offset</replaceable> <replaceable>size</replaceable> <replaceable>basename</replaceable>      <co id="setprobattrs.file.co" linkends="setprobattrs.file"/>
<replaceable>key</replaceable>:<replaceable>offset</replaceable> <replaceable>size</replaceable> <replaceable>basename</replaceable>      <coref linkend="setprobattrs.file.co"/>
&hellip;
content-length:<replaceable>content-length</replaceable>

<replaceable>binary data</replaceable></synopsis>
                <calloutlist>
                    <callout id="setprobattrs.prob_id" arearefs="setprobattrs.prob_id.co">
                        <para>
                            If zero, creates a new problem; otherwise
                            replaces an existing problem. Replacing a
                            problem has serious race conditions and is not
                            recommended, and has not been tested.
                        </para>
                        <para>
                            TODO: does it replace or selectively update?
                        </para>
                    </callout>
                    <callout id="setprobattrs.prob_type" arearefs="setprobattrs.prob_type.co">
                        <para>
                            A type returned from
                            <type>getprobtypes</type>. It may be omitted
                            if a problem ID is specified.
                        </para>
                    </callout>
                    <callout id="setprobattrs.prob_dependencies" arearefs="setprobattrs.prob_dependencies.co">
                        <para>
                            If specified, contains a comma-separated list
                            of numeric problem IDs for problems that
                            contestants before they will be allowed to
                            submit this problem. These problems must
                            already exist.
                        </para>
                    </callout>
                    <callout id="setprobattrs.key" arearefs="setprobattrs.key.co">
                        <para>
                            There must be one of these for each of the
                            non-file attributes described by
                            <type>getprobdescript</type>.
                        </para>
                    </callout>
                    <callout id="setprobattrs.file" arearefs="setprobattrs.file.co">
                        <para>
                            There must be one of these for each file
                            attribute described by
                            <type>getprobdescript</type>. The
                            <replaceable>offset</replaceable> and
                            <replaceable>size</replaceable> indicate a
                            subrange of the binary content that contains
                            the contents for this file.
                        </para>
                        <para>
                            When updating an existing problem, the header
                            value may instead be an ASCII dash
                            (<literal>-</literal>) to indicate that the
                            existing file data should be retained.
                        </para>
                        <para>
                            TODO: what is the
                            <replaceable>basename</replaceable> used for?
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section id="developer.csprotocol.getprobattrs">
                <title>Get problem attributes</title>
                <synopsis>getprobattrs
prob_id:<replaceable>id</replaceable>

ok
<replaceable>key</replaceable>:<replaceable>value</replaceable>
<replaceable>key</replaceable>:<replaceable>value</replaceable>
&hellip;</synopsis>
                <para>
                    This query returns only the key/value pairs that
                    contain scalars. It does not return the dependencies
                    or the files.
                </para>
            </section>
            <section id="developer.csprotocol.getprobfile">
                <title>Retrieve problem file</title>
                <synopsis>getprobfile
prob_id:<replaceable>id</replaceable>
file:<replaceable>filename</replaceable> <co id="getprobfile.file.co" linkends="getprobfile.file"/>

ok
content-length:<replaceable>content-length</replaceable>

<replaceable>binary data</replaceable></synopsis>
                <calloutlist>
                    <callout id="getprobfile.file" arearefs="getprobfile.file.co">
                        <para>
                            One of the file keys returned by
                            <type>getprobdescript</type>.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section id="developer.csprotocol.getproblems">
                <title>Get list of problems</title>
                <synopsis>getproblems

ok
id0:<replaceable>id</replaceable>     <co id="getproblems.id.co" linkends="getproblems.id"/>
code0:<replaceable>code</replaceable> <co id="getproblems.code.co" linkends="getproblems.code"/>
name0:<replaceable>name</replaceable> <co id="getproblems.name.co" linkends="getproblems.name"/>
id1:<replaceable>id</replaceable>
code1:<replaceable>code</replaceable>
name1:<replaceable>name</replaceable>
&hellip;</synopsis>
                <calloutlist>
                    <callout id="getproblems.id" arearefs="getproblems.id.co">
                        <para>
                            A numeric ID that is assigned by the server,
                            and used in other problem-related messages.
                        </para>
                    </callout>
                    <callout id="getproblems.code" arearefs="getproblems.code.co">
                        <para>
                            A short name for the problem (generally one
                            suitable for forming filenames). It is also
                            returned as the <parameter>shortname</parameter>
                            from <type>getprobattrs</type> queries.
                        </para>
                    </callout>
                    <callout id="getproblems.name" arearefs="getproblems.name.co">
                        <para>
                            A longer descriptive name for the problem. It
                            is also returned as the
                            <parameter>longname</parameter> from
                            <type>getprobattrs</type> queries.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section id="developer.csprotocol.submit">
                <title>Submit solution</title>
                <synopsis>submit
prob_id:<replaceable>id</replaceable>    <co id="submit.prob_id.co" linkends="submit.prob_id"/>
lang:<replaceable>language</replaceable> <co id="submit.lang.co" linkends="submit.lang"/>
content-length:<replaceable>content-length</replaceable>

<replaceable>binary data</replaceable></synopsis>
                <calloutlist>
                    <callout id="submit.prob_id" arearefs="submit.prob_id.co">
                        <para>
                            One of the problem IDs returned by
                            <type>getsubmissibleproblems</type>.
                        </para>
                    </callout>
                    <callout id="submit.lang" arearefs="submit.lang.co">
                        <para>
                            One of the languages returned by
                            <type>getlanguages</type>.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section id="developer.csprotocol.getsubmissionsource">
                <title>Get submitted source file</title>
                <synopsis>getsubmissionsource
submission_id:<replaceable>submission_id</replaceable>

ok
content-length:<replaceable>content-length</replaceable>

<replaceable>binary data</replaceable></synopsis>
            </section>
            <section id="developer.csprotocol.getsubmissions">
                <title>Get submissions</title>
                <synopsis>getsubmissions

ok
submission_id0:<replaceable>id</replaceable>
time0:<replaceable>time</replaceable>        <co id="getsubmissions.time.co" linkends="getsubmissions.time"/>
problem0:<replaceable>shortname</replaceable>
prob_id0:<replaceable>id</replaceable>
contesttime0:<replaceable>time</replaceable> <co id="getsubmissions.contesttime.co" linkends="getsubmissions.contesttime"/>
result0:<replaceable>result</replaceable>    <co id="getsubmissions.result.co" linkends="getsubmissions.result"/>
comment0:<replaceable>comment</replaceable>  <co id="getsubmissions.comment.co" linkends="getsubmissions.comment"/>
&hellip;</synopsis>
                <calloutlist>
                    <callout id="getsubmissions.time" arearefs="getsubmissions.time.co">
                        <para>
                            A UNIX timestamp in seconds (integer).
                        </para>
                    </callout>
                    <callout id="getsubmissions.contesttime" arearefs="getsubmissions.contesttime.co">
                        <para>
                            Seconds of contest time on the server to which
                            the server was connected (integer).
                        </para>
                    </callout>
                    <callout id="getsubmissions.result" arearefs="getsubmissions.result.co">
                        <para>
                            Either an integer with one of the values from
                            the <type>RunResult</type> enumeration, or the
                            string <literal>PENDING</literal> if no
                            evaluation has been done.
                        </para>
                    </callout>
                    <callout id="getsubmissions.comment" arearefs="getsubmissions.comment.co">
                        <para>
                            A human-readable status corresponding to
                            <parameter>result</parameter>, and possibly
                            containing extra information.
                        </para>
                    </callout>
                </calloutlist>
                <para>
                    Using <literal>getsubmissions_for_user</literal> in
                    place of <literal>getsubmissions</literal> and adding
                    a <parameter>user_id</parameter> header will give the
                    submissions for a single user.
                </para>
                <para>
                    TODO: are other fields generated?
                    <filename>serverconnection.C</filename> would suggest
                    so, but I can't see any code to generate them.
                </para>
            </section>
            <section id="developer.csprotocol.standings">
                <title>Get standings</title>
                <synopsis>standings

ok
<replaceable>grid</replaceable></synopsis>
                <para>
                    The standings are formatting using the <link
                        linkend="developer.csprotocol.grid">grid</link>
                    layout. It has the fixed columns listed below, followed by
                    a column per problem where the column header is the short
                    name of the problem.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>ID</literal></term>
                        <listitem>
                            <para>
                                The numeric user ID.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Team</literal></term>
                        <listitem>
                            <para>
                                The login username of the user.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Name</literal></term>
                        <listitem>
                            <para>
                                The full name of the user.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Contestant</literal></term>
                        <listitem>
                            <para>
                                Contains <literal>1</literal> if the user is a
                                contestant, and <literal>0</literal> if the
                                user is an unofficial entry.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Solved</literal></term>
                        <listitem>
                            <para>
                                The number of problems the user has solved.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Time</literal></term>
                        <listitem>
                            <para>
                                The number of seconds of time penality, as a
                                raw integer.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The value in each per-problem cell is an integer. If it is
                    positive, the problem has been solved with that number
                    of attempts (including the successful attempt).
                    Otherwise, it is the negative of the number of
                    attempts (all unsuccessful).
                </para>
            </section>
            <section id="developer.csprotocol.clarificationrequest">
                <title>Clarification request</title>
                <synopsis>clarificationrequest
prob_id:<replaceable>id</replaceable>        <co id="clarificationrequest.id.co" linkends="clarificationrequest.id"/>
question:<replaceable>question</replaceable> <co id="clarificationrequest.question.co" linkends="clarificationrequest.question"/></synopsis>
                <calloutlist>
                    <callout id="clarificationrequest.id" arearefs="clarificationrequest.id.co">
                        <para>
                            A numeric problem ID. May be zero or empty to
                            indicate a general request.
                        </para>
                    </callout>
                    <callout id="clarificationrequest.question" arearefs="clarificationrequest.question.co">
                        <para>
                            Newlines in the clarification request are
                            replaced by ASCII character 1, to distinguish
                            them from the newline terminating the header.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section id="developer.csprotocol.clarification">
                <title>Clarification reply</title>
                <synopsis>clarification
clarification_request_id:<replaceable>id</replaceable>
answer:<replaceable>answer</replaceable>
public:0|1</synopsis>
                <para>
                    As with clarification requests, newlines are replaced
                    with ASCII character 1.
                </para>
            </section>
            <section id="developer.csprotocol.getclarificationrequests">
                <title>Get clarification requests</title>
                <para>
                    This message will retrieve all clarification requests that
                    the user has permission to see. Note that when a
                    clarification is public, the user will be able to see the
                    question via the <link
                        linkend="developer.csprotocol.getclarifications">getclarifications</link>
                    message, yet might not have permission to see the original
                    clarification request with this message. This is simply an
                    artefact of the server design rather than a security
                    requirement.
                </para>
                <synopsis>getclarificationrequests

ok
id0:<replaceable>id</replaceable>
user_id0:<replaceable>user_id</replaceable>
problem0:<replaceable>shortname</replaceable>
time0:<replaceable>time</replaceable>
question0:<replaceable>text</replaceable>
&hellip;</synopsis>
                <para>
                    Refer to <link
                        linkend="developer.csprotocol.getclarifications">getclarifications</link>
                    for more information on the meanings of the fields.
                </para>
            </section>
            <section id="developer.csprotocol.getclarifications">
                <title>Get clarifications</title>
                <para>
                    This message will retrieve all clarifications that user has
                    permission to see.
                </para>
                <synopsis>getclarifications

ok
id0:<replaceable>id</replaceable>           <co id="getclarifications.id.co" linkends="getclarifications.id"/>
req_id0:<replaceable>id</replaceable>       <co id="getclarifications.req_id.co" linkends="getclarifications.req_id"/>
time0:<replaceable>time</replaceable>       <co id="getclarifications.time.co" linkends="getclarifications.time"/>
problem0:<replaceable>problem</replaceable> <co id="getclarifications.problem.co" linkends="getclarifications.problem"/>
question0:<replaceable>text</replaceable>   <co id="getclarifications.question.co" linkends="getclarifications.question"/>
answer0:<replaceable>answer</replaceable>   <co id="getclarifications.answer.co" linkends="getclarifications.answer"/>
&hellip;</synopsis>
                <calloutlist>
                    <callout id="getclarifications.id" arearefs="getclarifications.id.co">
                        <para>
                            Numeric ID associated with the clarification.
                        </para>
                    </callout>
                    <callout id="getclarifications.req_id" arearefs="getclarifications.req_id.co">
                        <para>
                            Numeric ID associated with the clarification
                            request that this clarification answers.
                        </para>
                    </callout>
                    <callout id="getclarifications.time" arearefs="getclarifications.time.co">
                        <para>
                            The time at which the clarification was made, as a
                            UNIX timestamp in seconds.
                        </para>
                    </callout>
                    <callout id="getclarifications.problem" arearefs="getclarifications.problem.co">
                        <para>
                            The short name of the problem to which this request
                            relates, or the string <literal>General</literal>
                            to indicate a general request.
                        </para>
                    </callout>
                    <callout id="getclarifications.question" arearefs="getclarifications.question.co">
                        <para>
                            The text of the clarification request, with
                            newlines replaced by ASCII character 1.
                        </para>
                    </callout>
                    <callout id="getclarifications.answer" arearefs="getclarifications.answer.co">
                        <para>
                            The text of the clarification reply, with newlines
                            replaced by ASCII character 1.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section id="developer.csprotocol.startstop">
                <title>Add start or stop time</title>
                <synopsis>startstop
action:<replaceable>action</replaceable> <co id="startstop.action.co"
    linkends="startstop.action"/>
time:<replaceable>time</replaceable>     <co id="startstop.time.co"
    linkends="startstop.time"/>
server_id:<replaceable>id</replaceable>  <co id="startstop.server_id.co"
    linkends="startstop.server_id"/></synopsis>
                <calloutlist>
                    <callout id="startstop.action" arearefs="startstop.action.co">
                        <para>Either <literal>start</literal> or <literal>stop</literal></para>
                    </callout>
                    <callout id="startstop.time" arearefs="startstop.time.co">
                        <para>A UNIX timestamp in seconds (integer)</para>
                    </callout>
                    <callout id="startstop.server_id" arearefs="startstop.server_id.co">
                        <para>
                            A numeric ID, <literal>all</literal> for all servers, or
                            <literal>self</literal> for the current server. If omitted, defaults
                            to <literal>all</literal>.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section id="developer.csprotocol.contesttime">
                <title>Get contest timing information</title>
                <synopsis>contesttime

ok
running:yes|no
time:<replaceable>seconds since start</replaceable>
remain:<replaceable>seconds remaining</replaceable></synopsis>
            </section>
            <section id="developer.csprotocol.subscribetime">
                <title>Subscribe to contest time events</title>
                <synopsis>subscribetime</synopsis>
                <para>
                    This message is equivalent to <link
                        linkend="developer.csprotocol.eventmap">subscribing</link>
                    to the <literal>startstop</literal> and
                    <literal>updateclock</literal> events, and may be removed
                    in future.
                </para>
                <para>
                    TODO: can we just remove this now?
                </para>
            </section>
            <section id="developer.csprotocol.eventmap">
                <title>Subscribe or unsubscribe from events</title>
                <synopsis>eventmap
action:subscribe|unsubscribe
event:<replaceable>event</replaceable></synopsis>
                <para>
                    Certain events are only sent to clients that have opted in
                    to receive them, using this command. It is legal to
                    subscribe to an event to which one is already subscribed,
                    or unsubscribe from an event to which one is not
                    subscribed. It is an error to attempt to subscribe or
                    unsubscribe from an event that doesn't exist, or for which
                    you do not have permission.
                </para>
                <para>
                    The currently defined events are
                </para>
                <itemizedlist>
                    <listitem><para><type>balloon</type></para></listitem>
                    <listitem><para><type>startstop</type></para></listitem>
                    <listitem><para><type>updateclarifications</type></para></listitem>
                    <listitem><para><type>updateclarificationrequests</type></para></listitem>
                    <listitem><para><type>updateclock</type></para></listitem>
                    <listitem><para><type>updatestandings</type></para></listitem>
                    <listitem><para><type>updatesubmissions</type></para></listitem>
                </itemizedlist>
            </section>
            <section id="developer.csprotocol.fetchfile.count">
                <title>Count files associated with submission</title>
                <synopsis>fetchfile
request:count
submission_id:<replaceable>id</replaceable></synopsis>
            </section>
            <section id="developer.csprotocol.fetchfile.data">
                <title>Fetch submission-related file</title>
                <synopsis>fetchfile
request:data
submission_id:<replaceable>id</replaceable>
index:<replaceable>index</replaceable></synopsis>
                <para>
                    When retrieving the files associated with a submission,
                    the typical approach is to first ask how many there are,
                    then retrieve them one at a time (the
                    <parameter>index</parameter> ranges from zero to one less
                    than the number of files). Note that this has a potential
                    race condition if new files are added while this is
                    happening.
                </para>
                <para>
                    Both judges and normal users can use this command, but for
                    contestants it will only return information they are
                    permitted to see (in particular, compilation failures).
                </para>
            </section>
            <section id="developer.csprotocol.subscribemark">
                <title>Register as a marker</title>
                <synopsis>subscribemark</synopsis>
                <para>
                    The marker daemon will issue this command after logging in
                    to register as a marker. Once it has done this, the server
                    will send it <type>mark</type> notifications when it has
                    something that needs marking.
                </para>
            </section>
            <section id="developer.csprotocol.mark">
                <title>Submit a mark for a problem</title>
                <synopsis>mark
submission_id:<replaceable>id</replaceable>
result:<replaceable>result</replaceable>                 <co id="mark.result.co" linkends="mark.result"/>
comment:<replaceable>comment</replaceable>               <coref linkend="mark.result.co"/>
file0:<replaceable>offset</replaceable> <replaceable>size</replaceable> <replaceable>description</replaceable> <co id="mark.file.co" linkends="mark.file"/>
&hellip;
content-length:<replaceable>content-length</replaceable>

<replaceable>binary data</replaceable></synopsis>
                <calloutlist>
                    <callout id="mark.result" arearefs="mark.result.co">
                        <para>
                            Refer to <link
                                linkend="developer.csprotocol.getsubmissions">getsubmissions</link>
                            for a description of the
                            <parameter>result</parameter> and
                            <parameter>replaceable</parameter> fields.
                        </para>
                    </callout>
                    <callout id="mark.file" arearefs="mark.file.co">
                        <para>
                            The files are encoded in the same way as for <link
                                linkend="developer.csprotocol.setprobattrs">setprobattrs</link>,
                            except that the headers are simply an enumeration,
                            and that the last sub-field is a human-readable
                            description rather than a filename.
                        </para>
                    </callout>
                </calloutlist>
                <para>
                    This command is used both by the GUI for judges to give
                    their verdicts, and for the marker to do its automated
                    marking. When a marker determines that the solution is
                    wrong, it will give a <parameter>result</parameter> of
                    <symbol>WRONG</symbol>, which the server will override to
                    <symbol>JUDGE</symbol>; however, this is subject to
                    change.
                </para>
            </section>
            <section id="developer.csprotocol.addserver">
                <title>Add a slave server</title>
                <synopsis>addserver
servername:<replaceable>name</replaceable>
ip:<replaceable>domain name</replaceable>
marker:yes|no
udppeerport:<replaceable>port number</replaceable></synopsis>
            </section>
            <section id="developer.csprotocol.getserverlist">
                <title>Get list of servers</title>
                <synopsis>getserverlist

ok
server0:<replaceable>domain name</replaceable>
server1:<replaceable>domain name</replaceable>
&hellip;</synopsis>
            </section>
        </section>
        <section id="developer.csprotocol.notifications">
            <title>Server notifications</title>
            <para>
                These messages are sent asynchronously to the client by
                the server. The client is not expected to explicitly
                acknowledge them. Some require explicit subscription (using
                <link linkend="developer.csprotocol.eventmap">eventmap</link>),
                while others will always be sent.
            </para>
            <para>
                TODO: document which are which. For the moment, look at the
                source: those sent with
                <methodname>ClientEventRegistry::triggerEvent</methodname> are
                sent only to subscribers, while those sent with
                <methodname>ClientEventRegistry::broadcastEvent</methodname>
                are sent to all users matching the method parameters.
            </para>
            <para>
                The messages whose names start with <literal>update</literal>
                are all incremental updates to the information shown to the
                user. Interactive clients will typically use them to update
                lists shown to the user, and possibly to signal that new
                information is available. Clients are discouraged from
                requesting a full update except when necessary (e.g.,
                immediately after connection).
            </para>
            <para>
                Servers are recommended not to send redundant updates to
                clients; however, the current server implementation may still
                do so under certain conditions. Clients must be prepared to
                accept redundant updates, and should avoid notifying the user
                of them. For relations that are normally immutable
                (clarification requests and clarifications), it is recommended
                that clients nevertheless update their internal database based
                on the notification, to allow for the possibility that these
                may become mutable in future.
            </para>
            <section id="developer.csprotocol.notifications.keepalive">
                <title>Keepalives</title>
                <synopsis>keepalive</synopsis>
                <para>
                    This message is broadcast to all clients at regular
                    intervals (see <filename>include/acmconfig.h</filename>),
                    to inform the client that the server is still alive. If
                    the client does not receive one for some interval, it will
                    assume that the connection has become stuck and terminate
                    it.
                </para>
                <para>
                    The keepalives are important because some routers
                    (possibly those performing NAT) will silently break
                    connections after a few minutes of inactivity without
                    sending a reset to the client; the keepalives both allow
                    this behaviour to be detected by the client, while at the
                    same time reducing the likelyhood by keeping data flowing
                    through the connection.
                </para>
            </section>
            <section id="developer.csprotocol.notifications.msg">
                <title>Message for user</title>
                <synopsis>msg
title:<replaceable>message title</replaceable>
text:<replaceable>message body</replaceable></synopsis>
                <para>
                    This is a general-purpose mechanism for the server to
                    asynchronously display notifications to the user.
                    Interactive clients are expected to display a dialog box
                    or some other form of notification.
                </para>
            </section>
            <section id="developer.csprotocol.notifications.startstop">
                <title>Contest state changes</title>
                <synopsis>startstop
action:start|stop</synopsis>
                <para>
                    This is sent when the contest either starts or stops.
                </para>
            </section>
            <section id="developer.csprotocol.notifications.updateclock">
                <title>Clock updates</title>
                <synopsis>updateclock</synopsis>
                <para>
                    This is sent when administrator intervention invalidates
                    the client's idea of how much time is left in the contest
                    (for example, by retroactively adding a start or stop
                    event). If the retroactive event changes the contest
                    state, this notification will be sent after the
                    <type>startstop</type> notification.
                </para>
                <para>
                    If a client displays the remaining contest time to the
                    user, it will need to use a <link
                        linkend="developer.csprotocol.contesttime">contesttime</link>
                    command to determine the new remaining time.
                </para>
                <para>
                    This message is not issued simply because the contest
                    stopped or started at a pre-determined time. If the client
                    tracks remaining contest time, it is responsible for
                    decrementing the remaining time while the contest is
                    running and not decrementing it while the contest is
                    stopped.
                </para>
            </section>
            <section id="developer.csprotocol.notifications.balloon">
                <title>Balloon notifications</title>
                <synopsis>balloon
server:<replaceable>server name</replaceable>
contestant:<replaceable>username</replaceable>
problem:<replaceable>short name</replaceable></synopsis>
                <para>
                    This message is sent when a problem is correctly solved.
                    It is used by the standalone <command>balloon</command>
                    client to display a message for each problem solved.
                </para>
            </section>
            <section id="developer.csprotocol.notifications.updatesubmissions">
                <title>Update submissions</title>
                <synopsis>updatesubmissions
submission_id:<replaceable>id</replaceable>
time:<replaceable>time</replaceable>
problem:<replaceable>shortname</replaceable>
prob_id:<replaceable>id</replaceable>
contesttime:<replaceable>time</replaceable>
result:<replaceable>result</replaceable>
comment:<replaceable>comment</replaceable></synopsis>
                <para>
                    This notification is sent when either there is a new
                    submission, or the state of an existing submission
                    changes. It has the same format as the reply to <link
                        linkend="developer.csprotocol.getsubmissions">getsubmissions</link>,
                    except that only a single submission is updated.
                </para>
            </section>
            <section id="developer.csprotocol.notifications.updateclarificationrequests">
                <title>Update clarification requests</title>
                <synopsis>updateclarificationrequests
id:<replaceable>id</replaceable>
user_id:<replaceable>user_id</replaceable>
problem:<replaceable>shortname</replaceable>
time:<replaceable>time</replaceable>
question:<replaceable>text</replaceable></synopsis>
                <para>
                    The fields are the same as for <link
                        linkend="developer.csprotocol.getclarificationrequests">getclarificationrequests</link>,
                    except that only one clarification request is updated.
                </para>
            </section>
            <section id="developer.csprotocol.notifications.updateclarifications">
                <title>Update clarifications</title>
                <synopsis>updateclarifications
id:<replaceable>id</replaceable>
req_id:<replaceable>id</replaceable>
time:<replaceable>time</replaceable>
problem:<replaceable>problem</replaceable>
question:<replaceable>text</replaceable>
answer:<replaceable>answer</replaceable></synopsis>
                <para>
                    The fields are the same as for <link
                        linkend="developer.csprotocol.getclarifications">getclarifications</link>,
                    except that only one clarification is updated.
                </para>
            </section>
            <section id="developer.csprotocol.notifications.updatestandings">
                <title>Update standings</title>
                <para>
                    TODO
                </para>
            </section>
            <section id="developer.csprotocol.notifications.close">
                <title>Connection closed</title>
                <synopsis>close</synopsis>
                <para>
                    This message is never sent over the wire, but is used
                    internally with the event registry to allow a callback to
                    be associated with the socket being closed. It is reserved
                    for future use as an explicit session termination
                    notification.
                </para>
            </section>
        </section>
    </section>

    <section id="developer.ssprotocol">
        <title>Server-to-server protocol</title>
        <section id="developer.ssprotocol.intro">
            <title>Introduction</title>
            <para>TODO</para>
        </section>
        <section id="developer.ssprotocol.udp">
            <title>Pure UDP protocol</title>
            <para>TODO</para>
        </section>
        <section id="developer.ssprotocol.udtcp">
            <title>Hybrid UDP/TCP protocol</title>
            <para>TODO</para>
        </section>
        <section id="developer.ssprotocol.messages">
            <title>Messages</title>
            <para>TODO</para>
        </section>
    </section>

    <section id="developer.server">
        <title>Server design</title>
        <section id="developer.server.actions">
            <title>Actions</title>
            <para>
                The server maintains a register of
                <firstterm>actions</firstterm> that clients can perform. Each
                action has a name, which is the type of the message that the
                client sends to the server to initiate the action (see <xref
                    linkend="developer.csprotocol"/>).
                Each action is represented in the server by a singleton
                instance of a subclass of <classname>ClientAction</classname>,
                which is registered using
                <methodname>ClientAction::registerAction</methodname>.
            </para>
            <para>
                The subclass will overload the
                <methodname>int_process</methodname> method. This method takes
                an incoming <classname>MessageBlock</classname> and returns
                <symbol>true</symbol> if the message was processed successfully
                (returning an error to the client is considered to be success),
                or <symbol>false</symbol> if there was an internal error. The
                callback will be made from the worker thread that received the
                message block from the client.
            </para>
            <para>
                Changes that arise from the message are performed in another
                thread, and a semaphore is posted when the processing is
                complete. Currently it is assumed that the changes cannot fail
                to be applied, and an <symbol>ok</symbol> response will always
                be sent back if the error checks in
                <methodname>int_process</methodname> passed. In practise, race
                conditions can occur e.g. two users might simultaneously
                attempt to add users with the same name; or system errors such
                as a full disk can occur.
            </para>
        </section>
        <section id="developer.server.modules">
            <title>Modules</title>
            <para>TODO</para>
        </section>
        <section id="developer.server.clientconnection">
            <title>Client connections</title>
            <para>
                The server communicates with the clients over SSL, using the
                <systemitem class="library">OpenSSL</systemitem> library. This
                complicates polling, because application-layer reads or writes
                can trigger both reads or writes on the underlying TCP socket,
                due to session renegotiations. Each call to OpenSSL that fails
                to make forward progress will return a status code indicating
                the condition on that socket that is required to make further
                progress. This also means that read and writes cannot be
                completely decoupled into separate threads; this isn't even
                thread-safe in OpenSSL.
            </para>
            <para>
                For each socket, the processing is a virtual equivalent to a
                loop of the following:
            </para>
            <procedure>
                <step id="developer.server.clientconnection.step-read">
                    <para>
                        Attempt to read data until no more can be read; store
                        the condition (e.g.,
                        <symbol>SSL_ERROR_WANT_READ</symbol>).
                    </para>
                </step>
                <step>
                    <para>
                        If there is data in the send queue, attempt to send
                        data until either <function>SSL_write</function>
                        returns an error or the send queue is empty.
                    </para>
                </step>
                <step>
                    <para>
                        Wait until forward progress can be made. The conditions
                        under which forward progress can potentially be made
                        are:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                The condition indicated by
                                <function>SSL_read</function>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                If the send queue was emptied, addition of more
                                data to the send queue.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                If the send queue was not successfully
                                emptied, the condition signalled by
                                <function>SSL_write</function>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </step>
            </procedure>
            <para>
                This could be done with a separate thread per connection, but
                the number of threads can be kept much smaller by distributing
                the work between threads: whenever it is necessary to wait for
                an event, the socket is given to the socket selector thread to
                be combined into a single call to <function>select</function>;
                once the event occurs, it is passed back to a worker thread to
                operate on. A socket is owned by only one thread at a time.
            </para>
            <para>
                Note that when waiting for data to become available for
                reading, one should first check
                <function>SSL_pending</function>, as OpenSSL may have already
                buffered data and thus prevent <function>select</function>
                from detecting that there is data to read.
            </para>
        </section>
        <section id="developer.server.threads">
            <title>Threads</title>
            <para>
                The server maintains a large number of threads:
            </para>
            <variablelist>
                <varlistentry>
                    <term>Worker threads</term>
                    <listitem>
                        <para>
                            A pool of threads is kept which handle socket I/O
                            Polymorphism is used to allow
                            the same worker thread to process server-to-server
                            sockets (UDP and TCP), client-server sockets (SSL
                            over TCP), and the sockets used for listening for
                            new connections.
                        </para>
                        <para>
                            The minimum and maximum number of worker threads
                            is defined in the configuration file, and scales
                            according to demand.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Socket selector</term>
                    <listitem>
                        <para>
                            This thread repeatedly calls
                            <function>poll()</function> on all active
                            sockets to find those with unprocessed data. When a
                            socket becomes ready for work, it finds an idle
                            work from the idle worker queue, and enqueues the
                            socket to it to be processed. At the same time, it
                            checks the number of idle workers to see if any
                            need to be created or destroyed. Once a worker
                            finishes processing the socket, it adds itself
                            back to the idle worker queue. This process is
                            implemented in the
                            <classname>ThreadedWaitableSet</classname>
                            class.
                        </para>
                        <para>
                            The socket selector need not only listen to
                            sockets: the <interface>Waitable</interface>
                            interface allows arbitrary file descriptors to be
                            used, and UNIX pipe pairs are used to signal
                            internal events such as data becoming available for
                            sending. There is also a special pipe pair that is
                            used to wake up this thread when the set of events
                            to monitor changes, or when it is time to shut
                            down.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Peer listener</term>
                    <listitem>
                        <para>
                            The peer listener continuously retrieves messages
                            from other servers, records them in the local
                            database (for replay if they are not processed
                            successfully), and enqueues them to the message
                            handler to process. It also immediately
                            acknowledges receipt of the message to the sending
                            server.
                        </para>
                        <para>
                            In the UDP messenger, this operation does blocking
                            reads on the UDP socket, and is entirely separate
                            from the worker threads or socket selector. In the
                            TCP/UDP messenger, the worker threads handle
                            reading the message from the socket, and this
                            thread just pulls messages from an internal queue.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Message handler</term>
                    <listitem>
                        <para>
                            The message handler polls a queue of
                            server-to-server messages, generated either
                            internally by client actions, or externally by
                            another server. It calls a virtual function on
                            each message to process it, and then marks it
                            processed in the database so that it need not be
                            reprocessed after a server shutdown.
                        </para>
                        <para>
                            This is not thread-safe, as the server could be
                            terminated between the message processing taking
                            effect in the database and the message being
                            recorded as processed, leading to it being
                            reprocessed during recovery (i.e., these actions
                            are not performed as a single database
                            transaction).
                        </para>
                        <para>
                            Locally generated messages (i.e., those that are
                            created in response to clients connected to the
                            current server also hold a pointer to a semaphore,
                            which is posted when processing is complete. This
                            is used to delay sending a response to the client
                            until the message has been processed. This is
                            necessary to avoid race conditions where a
                            subsequent message from the same client might
                            directly query the database and observe stale
                            information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Message resender</term>
                    <listitem>
                        <para>
                            The message resender checks for messages that have
                            not been acknowledged and resends them. Whenever
                            an acknowledgement is received from a server, it
                            checks for previously unacknowledged messages from
                            that server and resends them. If no
                            acknowledgements are received for 5 seconds, all
                            unacknowledged messages are resent.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Timed actions</term>
                    <listitem>
                        <para>
                            The timed actions thread keeps a priority queue of
                            actions to perform in future and executes these
                            actions at the appropriate time. It uses a timed
                            wait on a condition variable so that it can be
                            woken when either the earliest timed action is
                            ready to run or when a new timed action is added.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Marker timeout checker</term>
                    <listitem>
                        <para>
                            Checks that submissions are marked within a
                            timeout. If they are not, the marker is dropped
                            and the submission is re-enqueued. This thread is
                            currently dumb, polling once per second instead of
                            being interrupt-driven.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                TODO: add a list of the queues that carry data between threads,
                possibly with a diagram.
            </para>
        </section>
        <section id="developer.server.queues">
            <title>Queues</title>
            <para>
                The server uses a number of queues for communication between
                threads. These use the <classname>Queue</classname> container
                class, which allows thread-safe insertion and blocking and
                removal with timeout (non-blocking removal can be done using a
                timeout of zero). The queues that are used are:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        The message queue holds server-to-server messages
                        that have been received either from client actions or
                        from other servers, and are consumed by the message
                        handler thread.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The waitable queue holds sockets (or other instances
                        of the <interface>Waitable</interface> interface) that
                        need to be processed, and which are consumed by the
                        worker threads.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The timed actions queue holds timed actions that have
                        been registered but not yet seen by the timed actions
                        thread. The timed actions thread greedily pulls
                        actions from this queue and stores them internally in
                        a priority queue.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The ack queue records acknowledgements from other
                        servers. It is consumed by the message resender
                        thread, which after each ack will check that previous
                        messages have been received.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Each <classname>ClientConnection</classname> has a
                        queue of messages to send to the client, which are
                        posted from just about anywhere, and consumed by
                        worker threads as part of servicing the connection.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The hybrid UDP/TCP messenger stores messages it
                        receives in a queue. They are consumed by the message
                        handler thread.
                    </para>
                </listitem>
            </itemizedlist>
        </section>
        <section id="developer.server.permissions">
            <title>Permissions</title>
            <para>
                Each connection to the server is given a set of
                <firstterm>permissions</firstterm>, which are intended to be a
                reasonably fine-grained description of the actions that are
                possible. Examples of permissions are
                <symbol>PERMISSION_SEE_ALL_STANDINGS</symbol> and
                <symbol>PERMISSION_ADD_USER</symbol>. These permissions are
                stored in a <classname>PermissionSet</classname> in the
                <classname>ClientConnection</classname>. Operations that test
                whether an action is permitted use a
                <classname>PermissionTest</classname>, which is a boolean
                predicate on the set of permissions.
            </para>
            <para>
                Each user is given a user type in the database, and the
                mapping from user type to permission set is done when the
                user authenticates (thus, changing a user's type will not
                affect existing connections). At the time of writing, this
                mapping is hard-coded in <filename>permissionmap.C</filename>,
                but may eventually be read from the server configuration.
            </para>
            <para>
                When actions are registered, they are registered with a
                <classname>PermissionTest</classname> that indicates which
                users may perform the action. This removes the need for the
                action handlers to explicitly test the condition. However,
                where permission checks rely on more than just the action name
                and the permission set, handlers may still need to perform
                permission checks.
            </para>
        </section>
        <section id="developer.server.database">
            <title>Database connections</title>
            <para>TODO</para>
        </section>
    </section>

    <section id="developer.database">
        <title>Database layout</title>
        <section id="developer.database.contest">
            <title>Contest data</title>
            <para>TODO</para>
        </section>
        <section id="developer.database.peermessage">
            <title>Peer messages</title>
            <para>TODO</para>
        </section>
    </section>

    <section id="developer.client">
        <title>Qt client</title>
        <section id="developer.client.intro">
            <title>Introduction</title>
            <para>
                The GUI client is written using Qt 3, and is currently only
                supported or tested under GNU/Linux (Ubuntu 9.10 and Gentoo
                are known to work).
            </para>
        </section>
        <section id="developer.client.designer">
            <title>GUI</title>
            <para>
                The window layouts, as well as signal/slot connections are
                are edited in Qt Designer 3. Where menus contain items
                specific to a contest they are populated by the code, but
                all other controls are static and are enabled or disabled by
                signals.
            </para>
            <para>
                When additional intelligence is required from a dialog (for
                example, signal handlers to respond to menu items or button
                clicks), the class defined in Qt Designer is not directly
                used. Instead, the signal handlers are declared as pure
                virtual, and are implemented in a subclass. This avoids the
                need to maintain code within Qt Designer.
            </para>
        </section>
        <section id="developer.client.permissions">
            <title>Permissions</title>
            <para>
                While permissions are enforced by the server, the client aids
                the user by disabling all controls for which the user does not
                have permission. This is achieved by sending a
                <symbol>whatami</symbol> message to the server after login, to
                obtain a list of permissions. Each permission has a
                corresponding signal which is called when a permission is
                gained or lost. This is handled by
                <methodname>MainWindow::switchPermissions</methodname> in
                <filename>mainwindow.C</filename>. These signals are
                associated with the <methodname>setEnabled</methodname> or
                <methodname>setDisabled</methodname> slots on the menu items and
                widgets.
            </para>
            <para>
                All logged-in users have the <symbol>PERMISSION_AUTH</symbol>
                permission, so lack of this permission is also used to
                indicate that the user is not logged in (and hence controls
                such as <guimenuitem>Connect</guimenuitem> should be enabled).
            </para>
        </section>
        <section id="developer.client.threads">
            <title>Threads</title>
            <para>
                The client contains three threads:
            </para>
            <itemizedlist>
                <listitem>
                    <para>the main thread (also used by the GUI);</para>
                </listitem>
                <listitem>
                    <para>a receiver thread to receive messages</para>
                </listitem>
                <listitem>
                    <para>a keepalive thread to detect a failed
                        connection</para>
                </listitem>
            </itemizedlist>
            <para>
                The two auxiliary threads are created and managed by the
                <classname>ServerConnection</classname> class.
            </para>
            <para>
                The receiver thread listens on the SSL connection from
                incoming data; when any arrives, it tries to extract message
                blocks from it and process them. The nature of the processing
                depends on the message:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        For responses (<symbol>ok</symbol> and
                        <symbol>err</symbol>), the response is saved in a
                        shared variable and a condition variable is signalled
                        to wake up the main thread, which is waiting for it.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        For a <symbol>keepalive</symbol> message, a condition
                        variable is signalled to interrupt a timer in the
                        keepalive thread.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        For other messages, the event name is looked up in a
                        table of callbacks and the callback is made
                        synchronously.
                    </para>
                    <para>
                        Since the GUI cannot be manipulated directly from the
                        receiver thread, most callbacks in the Qt client use
                        the <classname>GUIEvent</classname> wrapper (or its
                        subclass <classname>NotifyEvent</classname>) to post
                        a copy of the message to the Qt event loop for
                        handling in the main thread.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                When sending a message to the server, the client waits
                synchronously for a response by blocking on the condition
                variable that is signalled by the receiver thread. This can
                cause the GUI to become unresponsive if the connection has
                died.
            </para>
            <para>
                The keepalive thread repeatedly does a timed wait for the
                receiver to inform it of a keepalive message. If it does not
                receive one before the timeout, it severs the connection and
                (if appropriate) wakes up the main thread to inform it of the
                timeout.
            </para>
        </section>
        <section id="developer.client.encoding">
            <title>Character encodings</title>
            <para>
                All (or almost all) user-visible strings in Abacuscm are in
                the Unicode character set. When manipulated internally, they
                are stored in the UTF-8 encoding. When passed into or out of
                Qt, they are converted to or from a
                <classname>QString</classname>, which is an opaque
                representation of a Unicode string.
            </para>
            <para>
                The code below shows the standard idioms for converting
                between <classname>QString</classname> and a C string:
            </para>
            <programlisting language="c++"><![CDATA[QString myqstring;
const char *mycstring;

myqstring = QString::fromUtf8("Hello world");
mycstring = (const char *) myqstring.utf8();
]]></programlisting>
        </section>
        <section id="developer.client.listview">
            <title>List views</title>
            <para>
                The GUI contains a number of list views, which are sortable
                (either by the user, or sorted by a fixed column such as
                time). Furthermore, the sorting is not a simple
                lexicographical sort on the value shown to the user (e.g.,
                numbers require a numeric sort, and times require sorting on
                the full time value rather than the time-of-day). It is also
                useful for the internals to be able to obtain the raw
                information from the list view item, instead of keeping a
                second copy. Finally, standard Qt 3 list views do not support
                filtering operations.
            </para>
            <para>
                Since Qt 3 does not support a general model-view paradigm (as
                GTK+ 2 and Qt 4 do), the
                <classname>SmartListViewItem</classname> class is used. It
                stores the human-readable form for each column, and has
                convenience functions to hide or show any item. For each list
                view, this class is subclassed by a class that
            </para>
            <itemizedlist>
                <listitem>
                    <para>stores raw values;</para>
                </listitem>
                <listitem>
                    <para>allows raw values to be set and queried, updating
                        the human-readable values as appropriate;</para>
                </listitem>
                <listitem>
                    <para>
                        overloads <methodname>compare</methodname> to implement
                        sorting based on the raw values;
                    </para>
                </listitem>
                <listitem>
                    <para>
                        overloads an <methodname>rtti</methodname> method to
                        indicate which type of item it is (mostly for
                        assertions).
                    </para>
                </listitem>
            </itemizedlist>
        </section>
    </section>

    <section id="developer.marker">
        <title>Marker</title>
        <section id="developer.marker.runlimit">
            <title>Enforcing constraints</title>
            <para>TODO</para>
        </section>
        <section id="developer.marker.java">
            <title>Java specifics</title>
            <para>TODO</para>
        </section>
    </section>
</chapter>
