<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE part PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<part id="developer">
    <title>Developer manual</title>
    <chapter id="developer.build">
        <title>Build system</title>
        <para>TODO</para>
    </chapter>

    <chapter id="developer.standard">
        <title>Coding standard</title>
        <section id="developer.standard.files">
            <title>Files</title>
            <itemizedlist>
                <listitem>
                    <para>
                        C++ files have the extension <filename
                            class="extension">.C</filename>, and are placed in
                        the <filename class="directory">src</filename>
                        directory.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Header files have the extension <filename
                            class="extension">.h</filename>, and are placed in
                        the <filename class="directory">include</filename>
                        directory.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        UI descriptions for Qt Designer have the extension
                        <filename class="extension">.ui</filename> and are
                        placed in the <filename
                            class="directory">ui</filename> directory.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Filenames are lower-case (apart from the extension)
                        and generally only use underscores to with a prefix to
                        indicate a group of related files (files generated by
                        <command>uic</command> are called
                        <filename>ui_<replaceable>filename</replaceable>.C</filename>,
                        while action handlers are called
                        <filename>act_<replaceable>actions</replaceable>.C</filename>).
                        There are a few exceptions to this rule, but they are
                        historic aberrations and may eventually be fixed.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Where a header file and a C++ file correspond, they
                        should have the same name. There are a few headers
                        that have no corresponding C++ file, and there are
                        also a few historic aberrations.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The <filename class="directory">obj</filename>,
                        <filename class="directory">bin</filename>,
                        <filename class="directory">lib</filename>,
                        <filename class="directory">modules</filename>,
                        <filename class="directory">tex-tmp</filename> and
                        <filename class="directory">deps</filename>
                        directories should only contain generated files, not
                        sources.
                    </para>
                </listitem>
            </itemizedlist>
        </section>
        <section id="developer.standard.style">
            <title>Coding style</title>
            <itemizedlist>
                <listitem>
                    <para>
                        Indentation uses tab characters, not spaces. Where
                        tabs are used to create alignment, the tab size should
                        be set to 4 spaces.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Opening braces are placed at the end of a line of
                        code, not on their own line.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Class names use
                        <classname><replaceable>InterCaps</replaceable></classname>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Private data members of classes are lower-case with
                        underscore separation and leading underscores e.g.,
                        <varname><replaceable>_private_member</replaceable></varname>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Methods use
                        <methodname><replaceable>camelCase</replaceable></methodname>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Non-method functions and variables use
                        lower-case and underscores e.g.,
                        <function><replaceable>my_function</replaceable></function>.
                    </para>
                </listitem>
            </itemizedlist>
        </section>
        <section id="developer.standard.singleton">
            <title>Singleton pattern</title>
            <para>TODO</para>
        </section>
    </chapter>

    <chapter id="developer.common">
        <title>Common infrastructure</title>
        <section id="developer.common.logging">
            <title>Logging</title>
            <para>
                General logging is done by calling
            </para>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>void <function>log</function></funcdef>
                    <paramdef>int <parameter>priority</parameter></paramdef>
                    <paramdef>const char *<parameter>format</parameter></paramdef>
                    <paramdef>...</paramdef>
                </funcprototype>
            </funcsynopsis>
            <para>
                The level and destination of logging is controlled by the
                configuration file. The <parameter>priority</parameter> values
                are taken from <function>syslog</function>. The
                <parameter>format</parameter> and variadic arguments are as
                used by <function>printf</function>.
            </para>
            <para>
                There is also an <function>lerror</function> macro which
                can be called when a system call fails unexpectedly. It logs
                the location of the error and the error message. Finally,
                there are some special-purpose functions for logging
                <systemitem class="library">OpenSSL</systemitem>
                errors (refer to <filename
                    class="headerfile">include/logger.h</filename>).
            </para>
        </section>
        <section id="developer.common.config">
            <title>Configuration files</title>
            <para>TODO</para>
        </section>
        <section id="developer.common.score">
            <title>Score comparison</title>
            <para>TODO</para>
        </section>
    </chapter>

    <chapter id="developer.csprotocol">
        <title>Client-server protocol</title>
        <section id="developer.csprotocol.intro">
            <title>Introduction</title>
            <para>
                The client-server protocol is encrypted with SSL over a TCP/IP
                connection. The transport is standard and so only the payload
                is discussed here.
            </para>
            <para>
                The protocol is semi-synchronous: the client makes requests
                and then blocks waiting for a synchronous reply from the
                server. However, the server may also sent asynchronous
                notifications to the client at any time.
            </para>
            <para>
                The protocol is text-based rather than binary. Lines are
                terminated by UNIX newline characters (<code>\n</code>), and
                the character encoding is UTF-8. Invalid UTF-8 encodings are
                not permitted, although currently this is not enforced.
            </para>
        </section>
        <section id="developer.csprotocol.format">
            <title>Message format</title>
            <para>
                A message consists of a type and a set of key/value pairs. The
                type appears first on a line of its own. After this, key/value
                pairs appear one per line, in the form
                <literal><replaceable>header</replaceable>:<replaceable>value</replaceable></literal>.
                At present, the parsing code has no restrictions on the type
                or the headers, but it is recommended that they be limited to
                ASCII alphanumerics and <literal>-</literal> (hyphen)
                characters. The protocol is case-sensitive.
            </para>
            <para>
                The message headers are terminated by a blank line. Usually
                this terminates the message, but a message may also have a
                binary content blob associated with it. The presence of this
                blob is indicated by a
                <parameter>content-length</parameter> header. The
                value of this header must be a non-negative decimal integer
                containing the number of bytes in the content blob. The content
                blob itself immediately follows the blank line that follows
                the headers.
            </para>
            <example>
                <title>A sample message</title>
                <synopsis>auth
user:<replaceable>username</replaceable>
pass:<replaceable>password</replaceable>

</synopsis>
            </example>
            <para>
                On top of this basic protocol, there are a few standard ways
                to encode more structured information. An ordered list of
                values is returned by using sequentially numbered headers,
                starting from 0 e.g., headers
                <parameter>header0</parameter>,
                <parameter>header1</parameter> and
                <parameter>header2</parameter>. Tables of values
                with fixed columns use the same approach for each column of
                the table.
            </para>
            <para>
                For messages that return general two-dimensional tables,
                headers <parameter>nrows</parameter> and
                <parameter>ncols</parameter> contain the dimensions
                of the table, and the elements are stored in headers called
                <parameter>row_<replaceable>row</replaceable>_<replaceable>column</replaceable></parameter>,
                where <replaceable>row</replaceable> and
                <replaceable>column</replaceable> are indexed from zero. Note
                that messages that use this scheme can only contain one table.
            </para>
        </section>
        <section id="developer.csprotocol.messagetypes">
            <title>Message types</title>
            <para>
                While most message types have a specific format, there is one
                special type of message: <type>ok</type>.
                This is used as a successful response to any message from the
                client, and the content depends on the message type sent by
                the client.
            </para>
            <section>
                <title>Client commands</title>
                <section>
                    <title>Authentication</title>
                    <synopsis>auth
user:<replaceable>username</replaceable>
pass:<replaceable>password</replaceable></synopsis>
                    <para>
                        This is typically the first message, used to log in.
                    </para>
                </section>
                <section>
                    <title>Creating a user</title>
                    <synopsis>adduser
username:<replaceable>username</replaceable>
friendlyname:<replaceable>team name</replaceable>
passwd:<replaceable>password</replaceable>
type:<replaceable>user type</replaceable> <co id="adduser.type.co"
    linkends="adduser.type"/></synopsis>
                    <calloutlist>
                        <callout id="adduser.type" arearefs="adduser.type.co">
                            <para>
                                One of
                                <literal>contestant</literal>,
                                <literal>observer</literal>,
                                <literal>judge</literal>,
                                <literal>admin</literal> or
                                <literal>marker</literal>.
                            </para>
                        </callout>
                    </calloutlist>
                </section>
                <section>
                    <title>Change own password</title>
                    <synopsis>passwd
newpass:<replaceable>password</replaceable></synopsis>
                </section>
                <section>
                    <title>Change another user's password</title>
                    <screen>id_passwd
user_id:<replaceable>id</replaceable> <co id="id_passwd.user_id.co" linkends="id_passwd.user_id"/>
newpass:<replaceable>password</replaceable></screen>
                    <calloutlist>
                        <callout id="id_passwd.user_id" arearefs="id_passwd.user_id.co">
                            <para>
                                The internal numeric ID, rather than a
                                username.
                            </para>
                        </callout>
                    </calloutlist>
                </section>
                <section>
                    <title>Add start or stop time</title>
                    <synopsis>startstop
action:<replaceable>action</replaceable> <co id="startstop.action.co"
    linkends="startstop.action"/>
time:<replaceable>time</replaceable>     <co id="startstop.time.co"
    linkends="startstop.time"/>
server_id:<replaceable>id</replaceable>  <co id="startstop.server_id.co"
    linkends="startstop.server_id"/></synopsis>
                    <calloutlist>
                        <callout id="startstop.action" arearefs="startstop.action.co">
                            <para>Either <literal>start</literal> or <literal>stop</literal></para>
                        </callout>
                        <callout id="startstop.time" arearefs="startstop.time.co">
                            <para>A UNIX timestamp in seconds (integer)</para>
                        </callout>
                        <callout id="startstop.server_id" arearefs="startstop.server_id.co">
                            <para>
                                A numeric ID, <literal>all</literal> for all servers, or
                                <literal>self</literal> for the current server. If omitted, defaults
                                to <literal>all</literal>.
                            </para>
                        </callout>
                    </calloutlist>
                    <para>
                        TODO: finish this list
                    </para>
                </section>
            </section>
        </section>
    </chapter>

    <chapter id="developer.ssprotocol">
        <title>Server-to-server protocol</title>
        <section id="developer.ssprotocol.intro">
            <title>Introduction</title>
            <para>TODO</para>
        </section>
        <section id="developer.ssprotocol.udp">
            <title>Pure UDP protocol</title>
            <para>TODO</para>
        </section>
        <section id="developer.ssprotocol.udtcp">
            <title>Hybrid UDP/TCP protocol</title>
            <para>TODO</para>
        </section>
        <section id="developer.ssprotocol.messages">
            <title>Messages</title>
            <para>TODO</para>
        </section>
    </chapter>

    <chapter id="developer.server">
        <title>Server design</title>
        <section id="developer.server.actions">
            <title>Actions</title>
            <para>
                The server maintains a register of
                <firstterm>actions</firstterm> that clients can perform. Each
                action has a name, which is the type of the message that the
                client sends to the server to initiate the action (see <xref
                    linkend="developer.csprotocol.messagetypes"/>).
                Each action is represented in the server by a singleton
                instance of a subclass of <classname>ClientAction</classname>,
                which is registered using
                <methodname>ClientAction::registerAction</methodname>.
            </para>
            <para>
                The subclass will overload the
                <methodname>int_process</methodname> method. This method takes
                an incoming <classname>MessageBlock</classname> and returns
                <symbol>true</symbol> if the message was processed successfully
                (returning an error to the client is considered to be success),
                or <symbol>false</symbol> if there was an internal error. The
                callback will be made from the worker thread that received the
                message block from the client.
            </para>
            <para>
                At present, any changes that arise from the message are not
                performed synchronously, but are merely enqueued for another
                thread to handle. This causes race conditions, because a
                following query from a client might not observe this new
                state. It also causes an <symbol>ok</symbol> response to be
                returned to the client before the message has even been
                processed, making it impossible to inform the client about
                errors in processing. Note that although error checks are done
                before the server-to-server message is created, race
                conditions can invalidate those checks (e.g., if two clients
                add a user with the same name at the same time, they may both
                be given the <symbol>ok</symbol> response).
            </para>
        </section>
        <section id="developer.server.modules">
            <title>Modules</title>
            <para>TODO</para>
        </section>
        <section id="developer.server.threads">
            <title>Threads</title>
            <para>
                The server maintains a large number of threads:
            </para>
            <variablelist>
                <varlistentry>
                    <term>Worker threads</term>
                    <listitem>
                        <para>
                            A pool of threads is kept which handle incoming
                            data on a socket. Polymorphism is used to allow
                            the same worker thread to process incoming data on
                            multiple types of sockets: server-to-server (UDP
                            and TCP) and client-to-server (SSL over TCP).
                        </para>
                        <para>
                            The minimum and maximum number of worker threads
                            is defined in the configuration file, and scales
                            according to demand.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Worker spawner</term>
                    <listitem>
                        <para>
                            This thread monitors the number of idle workers;
                            if it becomes too low, new workers are spawned.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Socket selector</term>
                    <listitem>
                        <para>
                            This thread repeatedly calls
                            <function>select()</function> on all active
                            sockets to find those with unprocessed data. It
                            then adds those sockets to a queue for the worker
                            threads to process them, after which they are
                            placed back on the active list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Peer listener</term>
                    <listitem>
                        <para>
                            The peer listener continuously retrieves messages
                            from other servers, records them in the local
                            database (for replay if they are not processed
                            successfully), and enqueues them to the message
                            handler to operate it. It also immediately
                            acknowledges the message to the sending server.
                        </para>
                        <para>
                            In the UDP messenger, this operation does blocking
                            reads on the UDP socket, and is entirely separate
                            from the worker threads or socket selector. In the
                            TCP/UDP messenger, the worker threads handle
                            reading the message from the socket, and this
                            thread just pulls messages from an internal queue.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Message handler</term>
                    <listitem>
                        <para>
                            The message handler polls a queue of
                            server-to-server messages, generated either
                            internally by client actions, or externally by
                            another server. It calls a virtual function on
                            each message to process it, and then marks it
                            processed in the database so that it need not be
                            reprocessed after a server shutdown.
                        </para>
                        <para>
                            This is not thread-safe, as the server could be
                            terminated between the message processing taking
                            effect in the database and the message being
                            recorded as processed, leading to it being
                            reprocessed during recovery (i.e., these actions
                            are not performed as a single database
                            transaction).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Message resender</term>
                    <listitem>
                        <para>
                            The message resender checks for messages that have
                            not been acknowledged and resends them. Whenever
                            an acknowledgement is received from a server, it
                            checks for previously unacknowledged messages from
                            that server and resends them. If no
                            acknowledgements are received for 5 seconds, all
                            unacknowledged messages are resent.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Timed actions</term>
                    <listitem>
                        <para>
                            The timed actions thread keeps a priority queue of
                            actions to perform in future and executes these
                            actions at the appropriate time.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Marker timeout checker</term>
                    <listitem>
                        <para>
                            Checks that submissions are marked within a
                            timeout. If they are not, the marker is dropped
                            and the submission is re-enqueued. This thread is
                            currently dumb, polling once per second instead of
                            being interrupt-driven.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                TODO: add a list of the queues that carry data between threads,
                possibly with a diagram.
            </para>
        </section>
        <section id="developer.server.permissions">
            <title>Permissions</title>
            <para>
                Each connection to the server is given a set of
                <firstterm>permissions</firstterm>, which are intended to be a
                reasonably fine-grained description of the actions that are
                possible. Examples of permissions are
                <symbol>PERMISSION_SEE_ALL_STANDINGS</symbol> and
                <symbol>PERMISSION_ADD_USER</symbol>. These permissions are
                stored in a <classname>PermissionSet</classname> in the
                <classname>ClientConnection</classname>. Operations that test
                whether an action is permitted use a
                <classname>PermissionTest</classname>, which is a boolean
                predicate on the set of permissions.
            </para>
            <para>
                Each user is given a user type in the database, and the
                mapping from user type to permission set is done when the
                user authenticates (thus, changing a user's type will not
                affect existing connections). At the time of writing, this
                mapping is hard-coded in <filename>permissionmap.C</filename>,
                but may eventually be read from the server configuration.
            </para>
            <para>
                When actions are registered, they are registered with a
                <classname>PermissionTest</classname> that indicates which
                users may perform the action. This removes the need for the
                action handlers to explicitly test the condition. However,
                where permission checks rely on more than just the action name
                and the permission set, handlers may still need to perform
                permission checks.
            </para>
        </section>
        <section id="developer.server.database">
            <title>Database connections</title>
            <para>TODO</para>
        </section>
    </chapter>

    <chapter id="developer.database">
        <title>Database layout</title>
        <section id="developer.database.contest">
            <title>Contest data</title>
            <para>TODO</para>
        </section>
        <section id="developer.database.peermessage">
            <title>Peer messages</title>
            <para>TODO</para>
        </section>
    </chapter>

    <chapter id="developer.client">
        <title>Qt client</title>
        <section id="developer.client.intro">
            <title>Introduction</title>
            <para>
                The GUI client is written using Qt 3, and is currently only
                supported or tested under GNU/Linux (Ubuntu 9.10 and Gentoo
                are known to work).
            </para>
        </section>
        <section id="developer.client.designer">
            <title>GUI</title>
            <para>
                The window layouts, as well as signal/slot connections are
                are edited in Qt Designer 3. Where menus contain items
                specific to a contest they are populated by the code, but
                all other controls are static and are enabled or disabled by
                signals.
            </para>
            <para>
                When additional intelligence is required from a dialog (for
                example, signal handlers to respond to menu items or button
                clicks), the class defined in Qt Designer is not directly
                used. Instead, the signal handlers are declared as pure
                virtual, and are implemented in a subclass. This avoids the
                need to maintain code within Qt Designer.
            </para>
        </section>
        <section id="developer.client.permissions">
            <title>Permissions</title>
            <para>
                While permissions are enforced by the server, the client aids
                the user by disabling all controls for which the user does not
                have permission. This is achieved by sending a
                <symbol>whatami</symbol> message to the server after login, to
                obtain a list of permissions. Each permission has a
                corresponding signal which is called when a permission is
                gained or lost. This is handled by
                <methodname>MainWindow::switchPermissions</methodname> in
                <filename>mainwindow.C</filename>. These signals are
                associated with the <methodname>setEnabled</methodname> or
                <methodname>setDisabled</methodname> slots on the menu items and
                widgets.
            </para>
            <para>
                All logged-in users have the <symbol>PERMISSION_AUTH</symbol>
                permission, so lack of this permission is also used to
                indicate that the user is not logged in (and hence controls
                such as <guimenuitem>Connect</guimenuitem> should be enabled).
            </para>
        </section>
        <section id="developer.client.threads">
            <title>Threads</title>
            <para>
                The client contains three threads:
            </para>
            <itemizedlist>
                <listitem>
                    <para>the main thread (also used by the GUI);</para>
                </listitem>
                <listitem>
                    <para>a receiver thread to receive messages</para>
                </listitem>
                <listitem>
                    <para>a keepalive thread to detect a failed
                        connection</para>
                </listitem>
            </itemizedlist>
            <para>
                The two auxiliary threads are created and managed by the
                <classname>ServerConnection</classname> class.
            </para>
            <para>
                The receiver thread listens on the SSL connection from
                incoming data; when any arrives, it tries to extract message
                blocks from it and process them. The nature of the processing
                depends on the message:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        For responses (<symbol>ok</symbol> and
                        <symbol>err</symbol>), the response is saved in a
                        shared variable and a condition variable is signalled
                        to wake up the main thread, which is waiting for it.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        For a <symbol>keepalive</symbol> message, a condition
                        variable is signalled to interrupt a timer in the
                        keepalive thread.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        For other messages, the event name is looked up in a
                        table of callbacks and the callback is made
                        synchronously.
                    </para>
                    <para>
                        Since the GUI cannot be manipulated directly from the
                        receiver thread, most callbacks in the Qt client use
                        the <classname>GUIEvent</classname> wrapper (or its
                        subclass <classname>NotifyEvent</classname>) to post
                        a copy of the message to the Qt event loop for
                        handling in the main thread.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                When sending a message to the server, the client waits
                synchronously for a response by blocking on the condition
                variable that is signalled by the receiver thread. This can
                cause the GUI to become unresponsive if the connection has
                died.
            </para>
            <para>
                The keepalive thread repeatedly does a timed wait for the
                receiver to inform it of a keepalive message. If it does not
                receive one before the timeout, it severs the connection and
                (if appropriate) wakes up the main thread to inform it of the
                timeout.
            </para>
        </section>
        <section id="developer.client.encoding">
            <title>Character encodings</title>
            <para>
                All (or almost all) user-visible strings in Abacuscm are in
                the Unicode character set. When manipulated internally, they
                are stored in the UTF-8 encoding. When passed into or out of
                Qt, they are converted to or from a
                <classname>QString</classname>, which is an opaque
                representation of a Unicode string.
            </para>
            <para>
                The code below shows the standard idioms for converting
                between <classname>QString</classname> and a C string:
            </para>
            <programlisting language="c++"><![CDATA[
QString myqstring;
const char *mycstring;

myqstring = QString::fromUtf8("Hello world");
mycstring = (const char *) myqstring.utf8();
]]></programlisting>
        </section>
        <section id="developer.client.listview">
            <title>List views</title>
            <para>
                The GUI contains a number of list views, which are sortable
                (either by the user, or sorted by a fixed column such as
                time). Furthermore, the sorting is not a simple
                lexicographical sort on the value shown to the user (e.g.,
                numbers require a numeric sort, and times require sorting on
                the full time value rather than the time-of-day). It is also
                useful for the internals to be able to obtain the raw
                information from the list view item, instead of keeping a
                second copy. Finally, standard Qt 3 list views do not support
                filtering operations.
            </para>
            <para>
                Since Qt 3 does not support a general model-view paradigm (as
                GTK+ 2 and Qt 4 do), the
                <classname>SmartListViewItem</classname> class is used. It
                stores the human-readable form for each column, and has
                convenience functions to hide or show any item. For each list
                view, this class is subclassed by a class that
            </para>
            <itemizedlist>
                <listitem>
                    <para>stores raw values;</para>
                </listitem>
                <listitem>
                    <para>allows raw values to be set and queried, updating
                        the human-readable values as appropriate;</para>
                </listitem>
                <listitem>
                    <para>
                        overloads <methodname>compare</methodname> to implement
                        sorting based on the raw values;
                    </para>
                </listitem>
                <listitem>
                    <para>
                        overloads an <methodname></methodname> method to
                        indicate which type of item it is (mostly for
                        assertions).
                    </para>
                </listitem>
            </itemizedlist>
        </section>
    </chapter>

    <chapter id="developer.marker">
        <title>Marker</title>
        <section id="developer.marker.runlimit">
            <title>Enforcing constraints</title>
            <para>TODO</para>
        </section>
        <section id="developer.marker.java">
            <title>Java specifics</title>
            <para>TODO</para>
        </section>
    </chapter>
</part>
